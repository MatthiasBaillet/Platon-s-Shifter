#!/usr/bin/env python3
# RECUPERATION Game.js v4.2 - Ecriture directe sans triple quotes
import os
import shutil

print("="*70)
print("üì• RECUPERATION Game.js v4.2 - Ecriture directe")
print("="*70)
print()

# Sauvegarder l'ancien
if os.path.exists('Game.js'):
    shutil.copy2('Game.js', 'Game.js.backup_ancien')
    print("üíæ Sauvegarde cr√©√©e : Game.js.backup_ancien")

# Cr√©er le nouveau Game.js
print("üìù Ecriture du nouveau Game.js...")

with open('Game.js', 'w', encoding='utf-8') as f:
    # Ecrire ligne par ligne (sans triple quotes)
    f.write('// PLATON\'S SHIFTER - Version 4.2 (Corrigee & Stable)\n')
    f.write('// Code final sans fuites memoire ni erreurs DOM\n\n')
    f.write('const GRID_SIZE = 40;\n')
    f.write('let PLAYER_SIZE = 30;\n')
    f.write('const ENEMY_SIZE = 25;\n')
    f.write('const ESSENCE_SIZE = 20;\n\n')
    f.write('let SHAPES = [\n')
    f.write('    { name: "TETRAEDRE", color: "#FF4444", speed: 6, attack: 2, special: "laser" },\n')
    f.write('    { name: "CUBE", color: "#D2B48C", speed: 2, attack: 1, special: "drawing" },\n')
    f.write('    { name: "OCTAEDRE", color: "#44FF44", speed: 4, attack: 3, special: "doubleJump" },\n')
    f.write('    { name: "DODECAEDRE", color: "#FFD700", speed: 3, attack: 4, special: "timeSlow" },\n')
    f.write('    { name: "ICOSAEDRE", color: "#FF00FF", speed: 5, attack: 5, special: "blast" }\n')
    f.write('];\n\n')
    f.write('let canvas = document.getElementById(\'gameCanvas\');\n')
    f.write('let ctx = canvas.getContext(\'2d\');\n')
    f.write('let player = { x: 400, y: 250, shape: 0, velocity: { x: 0, y: 0 }, energy: 0 };\n')
    f.write('let enemies = [];\n')
    f.write('let essences = [];\n')
    f.write('let terrainZones = [];\n')
    f.write('let startBase = null;\n')
    f.write('let enemyBase = null;\n')
    f.write('let unlockedShapes = [0];\n')
    f.write('let currentShape = 0;\n')
    f.write('let score = 0;\n')
    f.write('let health = 3;\n')
    f.write('let keys = {};\n')
    f.write('let gameLoop = null;\n')
    f.write('let lastTime = 0;\n\n')
    f.write('let powerCooldown = 3000;\n')
    f.write('let lastPowerUse = 0;\n')
    f.write('let isPowerActive = false;\n')
    f.write('let powerEffects = [];\n')
    f.write('let killsToUnlockCube = 5;\n')
    f.write('let enemiesKilledWithLaser = 0;\n')
    f.write('let laserCost = 2;\n\n')
    f.write('let mouseX = 0;\n')
    f.write('let mouseY = 0;\n')
    f.write('let isLaserActive = false;\n')
    f.write('let isDrawing = false;\n')
    f.write('let currentDrawingPoints = [];\n\n')
    f.write('// DECLARATION CRITIQUE : statusDiv\n')
    f.write('const statusDiv = document.getElementById(\'status\');\n')
    f.write('const killsDiv = document.getElementById(\'killsDisplay\');\n')
    f.write('const healthDiv = document.getElementById(\'health\');\n\n')
    f.write('document.addEventListener(\'DOMContentLoaded\', function() {\n')
    f.write('    if (!document.getElementById(\'gameCanvas\')) {\n')
    f.write('        alert(\'ERREUR: Canvas gameCanvas manquant dans le HTML!\');\n')
    f.write('        return;\n')
    f.write('    }\n')
    f.write('    init();\n')
    f.write('});\n\n')
    f.write('function init() {\n')
    f.write('    createEnemyBases();\n')
    f.write('    player.x = startBase.x;\n')
    f.write('    player.y = startBase.y;\n')
    f.write('    \n')
    f.write('    for (let i = 0; i < 8; i++) enemies.push(createEnemy());\n')
    f.write('    for (let i = 0; i < 3; i++) essences.push(createEssence());\n')
    f.write('    updateShapeButtons();\n')
    f.write('    updateKillsDisplay();\n')
    f.write('    updateEnergyDisplay();\n')
    f.write('    gameLoop = requestAnimationFrame(update);\n')
    f.write('}\n\n')
    f.write('function createEnemyBases() {\n')
    f.write('    startBase = {\n')
    f.write('        x: Math.random() * (canvas.width - GRID_SIZE * 8) + GRID_SIZE * 4,\n')
    f.write('        y: Math.random() * (canvas.height - GRID_SIZE * 8) + GRID_SIZE * 4,\n')
    f.write('        radius: GRID_SIZE * 1.5\n')
    f.write('    };\n\n')
    f.write('    enemyBase = {\n')
    f.write('        x: canvas.width * 0.75,\n')
    f.write('        y: canvas.height * 0.25,\n')
    f.write('        radius: GRID_SIZE * 1.5\n')
    f.write('    };\n')
    f.write('}\n\n')
    f.write('function createEnemy() {\n')
    f.write('    const base = enemyBase;\n')
    f.write('    const angle = Math.random() * Math.PI * 2;\n')
    f.write('    const distance = base.radius + Math.random() * 50;\n')
    f.write('    return {\n')
    f.write('        x: base.x + Math.cos(angle) * distance,\n')
    f.write('        y: base.y + Math.sin(angle) * distance,\n')
    f.write('        vx: (Math.random() - 0.5) * 2,\n')
    f.write('        vy: (Math.random() - 0.5) * 2,\n')
    f.write('        size: ENEMY_SIZE,\n')
    f.write('        color: \'#FF0000\',\n')
    f.write('        originalSpeed: 1\n')
    f.write('    };\n')
    f.write('}\n\n')
    f.write('function createEssence() {\n')
    f.write('    return {\n')
    f.write('        x: Math.random() * canvas.width,\n')
    f.write('        y: Math.random() * canvas.height,\n')
    f.write('        size: ESSENCE_SIZE,\n')
    f.write('        collected: false,\n')
    f.write('        pulsePhase: Math.random() * Math.PI * 2\n')
    f.write('    };\n')
    f.write('}\n\n')
    f.write('function update(timestamp) {\n')
    f.write('    if (timestamp - lastTime > 16) {\n')
    f.write('        lastTime = timestamp;\n')
    f.write('        ctx.fillStyle = \'rgba(0, 0, 0, 0.1)\';\n')
    f.write('        ctx.fillRect(0, 0, canvas.width, canvas.height);\n')
    f.write('        \n')
    f.write('        updatePlayer();\n')
    f.write('        updateEnemies();\n')
    f.write('        updatePowerEffects();\n')
    f.write('        drawStartBase();\n')
    f.write('        drawEnemyBase();\n')
    f.write('        drawLaser();\n')
    f.write('        drawDrawingPreview();\n')
    f.write('        drawEssences();\n')
    f.write('        drawEnemies();\n')
    f.write('        drawPowerEffects();\n')
    f.write('        drawTerrainZones();\n')
    f.write('        drawPlayer();\n')
    f.write('        checkCollisions();\n')
    f.write('        updatePowerUI();\n')
    f.write('    }\n')
    f.write('    gameLoop = requestAnimationFrame(update);\n')
    f.write('}\n\n')
    f.write('function updatePlayer() {\n')
    f.write('    let shape = SHAPES[currentShape];\n')
    f.write('    let targetVx = 0, targetVy = 0;\n')
    f.write('    if (keys[\'z\'] || keys[\'Z\'] || keys[\'w\'] || keys[\'W\'] || keys[\'ArrowUp\']) targetVy = -shape.speed;\n')
    f.write('    if (keys[\'s\'] || keys[\'S\'] || keys[\'ArrowDown\']) targetVy = shape.speed;\n')
    f.write('    if (keys[\'q\'] || keys[\'Q\'] || keys[\'a\'] || keys[\'A\'] || keys[\'ArrowLeft\']) targetVx = -shape.speed;\n')
    f.write('    if (keys[\'d\'] || keys[\'D\'] || keys[\'ArrowRight\']) targetVx = shape.speed;\n\n')
    f.write('    if (targetVx !== 0 || targetVy !== 0) {\n')
    f.write('        let futureX = player.x + targetVx;\n')
    f.write('        let futureY = player.y + targetVy;\n')
    f.write('        let canMove = true;\n')
    f.write('        terrainZones.forEach(zone => {\n')
    f.write('            let currentInside = isPointInPolygon({x: player.x, y: player.y}, zone.points);\n')
    f.write('            let futureInside = isPointInPolygon({x: futureX, y: futureY}, zone.points);\n')
    f.write('            if (!currentInside && futureInside) canMove = false;\n')
    f.write('        });\n')
    f.write('        if (canMove) {\n')
    f.write('            player.x = futureX;\n')
    f.write('            player.y = futureY;\n')
    f.write('        }\n')
    f.write('    }\n\n')
    f.write('    player.x = Math.max(PLAYER_SIZE/2, Math.min(canvas.width - PLAYER_SIZE/2, player.x));\n')
    f.write('    player.y = Math.max(PLAYER_SIZE/2, Math.min(canvas.height - PLAYER_SIZE/2, player.y));\n\n')
    f.write('    if (keys[\' \'] && shape.special === \'doubleJump\' && !isPowerActive) activateDoubleJump();\n')
    f.write('}\n\n')
    f.write('function isPointInPolygon(point, polygon) {\n')
    f.write('    let inside = false;\n')
    f.write('    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n')
    f.write('        let xi = polygon[i].x, yi = polygon[i].y;\n')
    f.write('        let xj = polygon[j].x, yj = polygon[j].y;\n')
    f.write('        let intersect = ((yi > point.y) != (yj > point.y))\n')
    f.write('            && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n')
    f.write('        if (intersect) inside = !inside;\n')
    f.write('    }\n')
    f.write('    return inside;\n')
    f.write('}\n\n')
    f.write('function drawTerrainZones() {\n')
    f.write('    terrainZones.forEach(zone => {\n')
    f.write('        if (zone.points.length > 2) {\n')
    f.write('            ctx.save();\n')
    f.write('            ctx.fillStyle = SHAPES[1].color;\n')
    f.write('            ctx.strokeStyle = \'#A0A0A0\';\n')
    f.write('            ctx.lineWidth = 2;\n')
    f.write('            ctx.beginPath();\n')
    f.write('            ctx.moveTo(zone.points[0].x, zone.points[0].y);\n')
    f.write('            for (let i = 1; i < zone.points.length; i++) ctx.lineTo(zone.points[i].x, zone.points[i].y);\n')
    f.write('            ctx.closePath();\n')
    f.write('            ctx.fill();\n')
    f.write('            ctx.stroke();\n')
    f.write('            ctx.restore();\n')
    f.write('        }\n')
    f.write('    });\n')
    f.write('}\n\n')
    f.write('function drawStartBase() {\n')
    f.write('    if (startBase) {\n')
    f.write('        ctx.save();\n')
    f.write('        ctx.fillStyle = \'rgba(100, 200, 255, 0.2)\';\n')
    f.write('        ctx.strokeStyle = \'#00ffff\';\n')
    f.write('        ctx.lineWidth = 3;\n')
    f.write('        ctx.beginPath();\n')
    f.write('        ctx.arc(startBase.x, startBase.y, startBase.radius, 0, Math.PI * 2);\n')
    f.write('        ctx.fill();\n')
    f.write('        ctx.stroke();\n')
    f.write('        ctx.restore();\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function drawEnemyBase() {\n')
    f.write('    if (!enemyBase) return;\n')
    f.write('    ctx.save();\n')
    f.write('    ctx.fillStyle = \'rgba(255, 0, 0, 0.2)\';\n')
    f.write('    ctx.strokeStyle = \'#ff4444\';\n')
    f.write('    ctx.lineWidth = 2;\n')
    f.write('    ctx.beginPath();\n')
    f.write('    ctx.arc(enemyBase.x, enemyBase.y, enemyBase.radius, 0, Math.PI * 2);\n')
    f.write('        ctx.fill();\n')
    f.write('        ctx.stroke();\n')
    f.write('        ctx.restore();\n')
    f.write('}\n\n')
    f.write('function drawDrawingPreview() {\n')
    f.write('    if (isDrawing && currentDrawingPoints.length > 1) {\n')
    f.write('        ctx.save();\n')
    f.write('        ctx.strokeStyle = \'#A0A0A0\';\n')
    f.write('        ctx.lineWidth = 2;\n')
    f.write('        ctx.setLineDash([5, 5]);\n')
    f.write('        ctx.beginPath();\n')
    f.write('        ctx.moveTo(currentDrawingPoints[0].x, currentDrawingPoints[0].y);\n')
    f.write('        for (let i = 1; i < currentDrawingPoints.length; i++) ctx.lineTo(currentDrawingPoints[i].x, currentDrawingPoints[i].y);\n')
    f.write('        ctx.stroke();\n')
    f.write('        ctx.restore();\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function startDrawing(x, y) {\n')
    f.write('    currentDrawingPoints = [{x: x, y: y}];\n')
    f.write('    isDrawing = true;\n')
    f.write('}\n\n')
    f.write('function continueDrawing(x, y) {\n')
    f.write('    if (isDrawing) {\n')
    f.write('        let lastPoint = currentDrawingPoints[currentDrawingPoints.length - 1];\n')
    f.write('        let distance = Math.sqrt((x - lastPoint.x) ** 2 + (y - lastPoint.y) ** 2);\n')
    f.write('        if (distance > 10) currentDrawingPoints.push({x: x, y: y});\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function finishDrawing() {\n')
    f.write('    if (currentDrawingPoints.length < 3) {\n')
    f.write('        statusDiv.textContent = \'[ERREUR] Zone trop petite\';\n')
    f.write('        setTimeout(() => statusDiv.textContent = \'Jouez !\', 3000);\n')
    f.write('        isDrawing = false;\n')
    f.write('        currentDrawingPoints = [];\n')
    f.write('        return;\n')
    f.write('    }\n\n')
    f.write('    let area = 0;\n')
    f.write('    for (let i = 0; i < currentDrawingPoints.length - 1; i++) {\n')
    f.write('        let j = (i + 1) % currentDrawingPoints.length;\n')
    f.write('        area += currentDrawingPoints[i].x * currentDrawingPoints[j].y;\n')
    f.write('        area -= currentDrawingPoints[i].y * currentDrawingPoints[j].x;\n')
    f.write('    }\n')
    f.write('    area = Math.abs(area / 2);\n\n')
    f.write('    if (area < 1000) {\n')
    f.write('        statusDiv.textContent = \'[ERREUR] Surface min: 1000\';\n')
    f.write('        setTimeout(() => statusDiv.textContent = \'Jouez !\', 3000);\n')
    f.write('        isDrawing = false;\n')
    f.write('        currentDrawingPoints = [];\n')
    f.write('        return;\n')
    f.write('    }\n\n')
    f.write('    terrainZones.push({ points: [...currentDrawingPoints], area: area });\n')
    f.write('    currentDrawingPoints = [];\n')
    f.write('    isDrawing = false;\n')
    f.write('    statusDiv.textContent = `[OK] Zone creee ! Surface: ${Math.floor(area)}`;\n')
    f.write('    setTimeout(() => statusDiv.textContent = \'Jouez !\', 3000);\n')
    f.write('    lastPowerUse = Date.now();\n')
    f.write('        isPowerActive = true;\n')
    f.write('        setTimeout(() => { isPowerActive = false; }, getPowerDuration());\n')
    f.write('}\n\n')
    f.write('function activatePower() {\n')
    f.write('    if (isPowerActive) return;\n')
    f.write('    \n')
    f.write('    let now = Date.now();\n')
    f.write('    let timeSinceLastUse = now - lastPowerUse;\n')
    f.write('    if (timeSinceLastUse < powerCooldown) return;\n\n')
    f.write('    let shape = SHAPES[currentShape];\n')
    f.write('    switch(shape.special) {\n')
    f.write('        case \'laser\': activateLaser(); break;\n')
    f.write('        case \'drawing\': break;\n')
    f.write('        case \'doubleJump\': activateDoubleJump(); break;\n')
    f.write('        case \'timeSlow\': activateTimeSlow(); break;\n')
    f.write('        case \'blast\': activateBlast(); break;\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function activateLaser() {\n')
    f.write('    const cost = laserCost;\n')
    f.write('    if (player.energy < cost) {\n')
    f.write('        statusDiv.textContent = `[ERREUR] Energie insuffisante ! ${cost} requise`;\n')
    f.write('        setTimeout(() => statusDiv.textContent = \'Jouez !\', 3000);\n')
    f.write('        return;\n')
    f.write('    }\n')
    f.write('    \n')
    f.write('    player.energy -= cost;\n')
    f.write('    updateEnergyDisplay();\n')
    f.write('    isLaserActive = true;\n')
    f.write('    powerEffects.push({ type: \'laserCharge\', x: player.x, y: player.y, duration: 200, startTime: Date.now() });\n')
    f.write('    setTimeout(() => isLaserActive = false, 500);\n')
    f.write('    lastPowerUse = Date.now();\n')
    f.write('    isPowerActive = true;\n')
    f.write('    setTimeout(() => { isPowerActive = false; }, getPowerDuration());\n')
    f.write('}\n\n')
    f.write('function drawLaser() {\n')
    f.write('    if (isLaserActive) {\n')
    f.write('        ctx.save();\n')
    f.write('        ctx.strokeStyle = \'#FF4444\';\n')
    f.write('        ctx.lineWidth = 4;\n')
    f.write('        ctx.shadowBlur = 10;\n')
    f.write('        ctx.shadowColor = \'#FF4444\';\n')
    f.write('        ctx.beginPath();\n')
    f.write('        ctx.moveTo(player.x, player.y);\n')
    f.write('        ctx.lineTo(mouseX, mouseY);\n')
    f.write('        ctx.stroke();\n')
    f.write('        ctx.beginPath();\n')
    f.write('        ctx.arc(mouseX, mouseY, 10, 0, Math.PI * 2);\n')
    f.write('        ctx.fillStyle = \'#FF4444\';\n')
    f.write('        ctx.fill();\n')
    f.write('        ctx.restore();\n')
    f.write('        checkLaserCollision();\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function checkLaserCollision() {\n')
    f.write('    enemies.forEach((enemy, index) => {\n')
    f.write('        let A = mouseX - player.x;\n')
    f.write('        let B = mouseY - player.y;\n')
    f.write('        let C = enemy.x - player.x;\n')
    f.write('        let D = enemy.y - player.y;\n')
    f.write('        let dot = A * C + B * D;\n')
    f.write('        let lenSq = A * A + B * B;\n')
    f.write('        let param = lenSq !== 0 ? dot / lenSq : -1;\n')
    f.write('        let closestX = param < 0 ? player.x : param > 1 ? mouseX : player.x + param * A;\n')
    f.write('        let closestY = param < 0 ? player.y : param > 1 ? mouseY : player.y + param * B;\n')
    f.write('        let dx = enemy.x - closestX;\n')
    f.write('        let dy = enemy.y - closestY;\n')
    f.write('        let distance = Math.sqrt(dx*dx + dy*dy);\n')
    f.write('        \n')
    f.write('        if (distance < enemy.size) {\n')
    f.write('            enemies.splice(index, 1);\n')
    f.write('            score += 100;\n')
    f.write('            document.getElementById(\'score\').textContent = score;\n')
    f.write('            if (currentShape === 0) {\n')
    f.write('                enemiesKilledWithLaser++;\n')
    f.write('                updateKillsDisplay();\n')
    f.write('                if (enemiesKilledWithLaser >= killsToUnlockCube && !unlockedShapes.includes(1)) {\n')
    f.write('                    unlockedShapes.push(1);\n')
    f.write('                    updateShapeButtons();\n')
    f.write('                    statusDiv.textContent = \'[OK] CUBE DEBLOQUE !\';\n')
    f.write('                    setTimeout(() => statusDiv.textContent = \'Jouez !\', 4000);\n')
    f.write('                }\n')
    f.write('            }\n')
    f.write('        }\n')
    f.write('    });\n')
    f.write('}\n\n')
    f.write('function activateDoubleJump() {\n')
    f.write('    player.y -= 100;\n')
    f.write('    powerEffects.push({ type: \'doubleJump\', x: player.x, y: player.y + 50, duration: 500, startTime: Date.now() });\n')
    f.write('    lastPowerUse = Date.now();\n')
    f.write('    isPowerActive = true;\n')
    f.write('    setTimeout(() => { isPowerActive = false; }, getPowerDuration());\n')
    f.write('}\n\n')
    f.write('function activateTimeSlow() {\n')
    f.write('    enemies.forEach(enemy => { enemy.vx *= 0.3; enemy.vy *= 0.3; });\n')
    f.write('    powerEffects.push({ type: \'timeSlow\', x: canvas.width/2, y: canvas.height/2, duration: 3000, startTime: Date.now() });\n')
    f.write('    lastPowerUse = Date.now();\n')
    f.write('    isPowerActive = true;\n')
    f.write('    setTimeout(() => { isPowerActive = false; deactivatePowerEffects(); }, getPowerDuration());\n')
    f.write('}\n\n')
    f.write('function activateBlast() {\n')
    f.write('    let blastRadius = 150;\n')
    f.write('    let enemiesDestroyed = 0;\n')
    f.write('    enemies.forEach((enemy, index) => {\n')
    f.write('        let dx = player.x - enemy.x;\n')
    f.write('        let dy = player.y - enemy.y;\n')
    f.write('        let distance = Math.sqrt(dx*dx + dy*dy);\n')
    f.write('        if (distance < blastRadius) {\n')
    f.write('            enemy.x = Math.random() * canvas.width;\n')
    f.write('            enemy.y = Math.random() * canvas.height;\n')
    f.write('            enemiesDestroyed++;\n')
    f.write('            score += 50 * enemiesDestroyed;\n')
    f.write('            document.getElementById(\'score\').textContent = score;\n')
    f.write('        }\n')
    f.write('    });\n')
    f.write('    powerEffects.push({ type: \'blast\', x: player.x, y: player.y, duration: 500, startTime: Date.now(), radius: blastRadius });\n')
    f.write('    lastPowerUse = Date.now();\n')
    f.write('    isPowerActive = true;\n')
    f.write('    setTimeout(() => { isPowerActive = false; }, getPowerDuration());\n')
    f.write('}\n\n')
    f.write('function deactivatePowerEffects() {\n')
    f.write('    if (SHAPES[currentShape].special === \'timeSlow\') {\n')
    f.write('        enemies.forEach(enemy => {\n')
    f.write('            enemy.vx = (Math.random() - 0.5) * 2;\n')
    f.write('            enemy.vy = (Math.random() - 0.5) * 2;\n')
    f.write('        });\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function updatePowerEffects() {\n')
    f.write('    powerEffects = powerEffects.filter(effect => Date.now() - effect.startTime < effect.duration);\n')
    f.write('}\n\n')
    f.write('function drawPowerEffects() {\n')
    f.write('    powerEffects.forEach(effect => {\n')
    f.write('        let elapsed = Date.now() - effect.startTime;\n')
    f.write('        let progress = elapsed / effect.duration;\n')
    f.write('        ctx.save();\n')
    f.write('        switch(effect.type) {\n')
    f.write('            case \'laserCharge\':\n')
    f.write('                ctx.strokeStyle = \'#FF4444\';\n')
    f.write('                ctx.lineWidth = 2;\n')
    f.write('                ctx.beginPath();\n')
    f.write('                ctx.arc(effect.x, effect.y, PLAYER_SIZE * (1 + progress), 0, Math.PI * 2);\n')
    f.write('                ctx.stroke();\n')
    f.write('                break;\n')
    f.write('            case \'doubleJump\':\n')
    f.write('                ctx.fillStyle = `rgba(68, 255, 68, ${1 - progress})`;\n')
    f.write('                ctx.fillRect(effect.x - 20, effect.y - 20, 40, 40);\n')
    f.write('                break;\n')
    f.write('            case \'timeSlow\':\n')
    f.write('                ctx.fillStyle = `rgba(255, 215, 0, ${0.1 * (1 - progress)})`;\n')
    f.write('                ctx.fillRect(0, 0, canvas.width, canvas.height);\n')
    f.write('                break;\n')
    f.write('            case \'blast\':\n')
    f.write('                ctx.strokeStyle = \'#FF00FF\';\n')
    f.write('                ctx.lineWidth = 2;\n')
    f.write('                ctx.beginPath();\n')
    f.write('                ctx.arc(effect.x, effect.y, effect.radius * progress, 0, Math.PI * 2);\n')
    f.write('                ctx.stroke();\n')
    f.write('                break;\n')
    f.write('        }\n')
    f.write('        ctx.restore();\n')
    f.write('    });\n')
    f.write('}\n\n')
    f.write('function updatePowerUI() {\n')
    f.write('    let now = Date.now();\n')
    f.write('    let timeSinceLastUse = now - lastPowerUse;\n')
    f.write('    let cooldownProgress = Math.min(timeSinceLastUse / powerCooldown, 1);\n')
    f.write('    let cooldownBar = document.getElementById(\'powerCooldown\');\n')
    f.write('    let powerStatus = document.getElementById(\'powerStatus\');\n')
    f.write('    \n')
    f.write('    if (isPowerActive) {\n')
    f.write('        if (cooldownBar) cooldownBar.style.width = \'100%\';\n')
    f.write('        if (cooldownBar) cooldownBar.classList.add(\'active\');\n')
    f.write('        if (powerStatus) powerStatus.textContent = `[POUVOIR] ${SHAPES[currentShape].special} ACTIF !`;\n')
    f.write('    } else if (cooldownProgress < 1) {\n')
    f.write('        if (cooldownBar) cooldownBar.style.width = `${cooldownProgress * 100}%`;\n')
    f.write('        if (cooldownBar) cooldownBar.classList.remove(\'active\');\n')
    f.write('        if (powerStatus) powerStatus.textContent = `[RECHARGEMENT] (${Math.ceil((powerCooldown - timeSinceLastUse) / 1000)}s)`;\n')
    f.write('    } else {\n')
    f.write('        if (cooldownBar) cooldownBar.style.width = \'100%\';\n')
    f.write('        if (cooldownBar) cooldownBar.classList.add(\'active\');\n')
    f.write('        if (powerStatus) powerStatus.textContent = `[CLIC] ${SHAPES[currentShape].special.toUpperCase()}`;\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function updateKillsDisplay() {\n')
    f.write('    if (unlockedShapes.includes(1)) {\n')
    f.write('        killsDiv.textContent = `Kills: ${enemiesKilledWithLaser} [OK]`;\n')
    f.write('    } else {\n')
    f.write('        killsDiv.textContent = `Kills: ${enemiesKilledWithLaser}/${killsToUnlockCube} [VERROU]`;\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function updateEnergyDisplay() {\n')
    f.write('    document.getElementById(\'energy\').textContent = player.energy;\n')
    f.write('}\n\n')
    f.write('function updateShapeButtons() {\n')
    f.write('    document.querySelectorAll(\'.shape-btn\').forEach((btn, index) => {\n')
    f.write('        btn.classList.toggle(\'locked\', !unlockedShapes.includes(index));\n')
    f.write('        btn.classList.toggle(\'active\', index === currentShape);\n')
    f.write('    });\n')
    f.write('    document.getElementById(\'currentForm\').textContent = `FORME: ${SHAPES[currentShape].name}`;\n')
    f.write('    updateKillsDisplay();\n')
    f.write('}\n\n')
    f.write('function changeShape(shapeIndex) {\n')
    f.write('    if (unlockedShapes.includes(shapeIndex)) {\n')
    f.write('        currentShape = shapeIndex;\n')
    f.write('        updateShapeButtons();\n')
    f.write('        ctx.fillStyle = \'rgba(255, 255, 255, 0.5)\';\n')
    f.write('        ctx.fillRect(0, 0, canvas.width, canvas.height);\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function gameOver() {\n')
    f.write('    cancelAnimationFrame(gameLoop);\n')
    f.write('    document.getElementById(\'finalScore\').textContent = score;\n')
    f.write('    document.getElementById(\'finalEnergy\').textContent = player.energy;\n')
    f.write('    document.getElementById(\'finalBlocks\').textContent = terrainZones.length;\n')
    f.write('    document.getElementById(\'gameOver\').style.display = \'block\';\n')
    f.write('}\n\n')
    f.write('function restartGame() {\n')
    f.write('    location.reload();\n')
    f.write('}\n\n')
    f.write('// GESTIONNAIRE GLOBAL DE CLIC\n')
    f.write('canvas.addEventListener(\'mousedown\', (e) => {\n')
    f.write('    const rect = canvas.getBoundingClientRect();\n')
    f.write('    const x = e.clientX - rect.left;\n')
    f.write('    const y = e.clientY - rect.top;\n')
    f.write('    \n')
    f.write('    if (currentShape === 1 && unlockedShapes.includes(1)) {\n')
    f.write('        startDrawing(x, y);\n')
    f.write('    } else {\n')
    f.write('        mouseX = x;\n')
    f.write('        mouseY = y;\n')
    f.write('        activatePower();\n')
    f.write('    }\n')
    f.write('});\n\n')
    f.write('canvas.addEventListener(\'mousemove\', (e) => {\n')
    f.write('    const rect = canvas.getBoundingClientRect();\n')
    f.write('    mouseX = e.clientX - rect.left;\n')
    f.write('    mouseY = e.clientY - rect.top;\n')
    f.write('    \n')
    f.write('    if (isDrawing) {\n')
    f.write('        continueDrawing(mouseX, mouseY);\n')
    f.write('    }\n')
    f.write('});\n\n')
    f.write('canvas.addEventListener(\'mouseup\', () => {\n')
    f.write('    if (isDrawing) {\n')
    f.write('        finishDrawing();\n')
    f.write('    }\n')
    f.write('});\n\n')
    f.write('document.addEventListener(\'keydown\', (e) => {\n')
    f.write('    keys[e.key] = true;\n')
    f.write('    if (e.key >= \'1\' && e.key <= \'5\') changeShape(parseInt(e.key) - 1);\n')
    f.write('    if (e.key === \'Tab\') { e.preventDefault(); toggleCustomizationPanel(); }\n')
    f.write('});\n\n')
    f.write('document.addEventListener(\'keyup\', (e) => { keys[e.key] = false; });\n\n')
    f.write('function toggleCustomizationPanel() {\n')
    f.write('    const panel = document.getElementById(\'customPanel\');\n')
    f.write('    panel.classList.toggle(\'active\');\n')
    f.write('    document.querySelector(\'.tab-indicator\').style.display = \'none\';\n')
    f.write('}\n\n')
    f.write('function updateValue(sliderId) {\n')
    f.write('    const slider = document.getElementById(sliderId);\n')
    f.write('    const valueSpan = document.getElementById(sliderId + \'Value\');\n')
    f.write('    valueSpan.textContent = slider.value;\n')
    f.write('    \n')
    f.write('    if (sliderId === \'laserCost\') {\n')
    f.write('        laserCost = parseInt(slider.value);\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function applyChanges() {\n')
    f.write('    gameSpeed = parseInt(document.getElementById(\'gameSpeed\').value);\n')
    f.write('    PLAYER_SIZE = parseInt(document.getElementById(\'playerSize\').value);\n')
    f.write('    laserCost = parseInt(document.getElementById(\'laserCost\').value);\n')
    f.write('    let newEnemyCount = parseInt(document.getElementById(\'enemyCount\').value);\n')
    f.write('    while (enemies.length < newEnemyCount) enemies.push(createEnemy());\n')
    f.write('    while (enemies.length > newEnemyCount) enemies.pop();\n')
    f.write('    \n')
    f.write('    statusDiv.textContent = \'[OK] Changements appliques !\';\n')
    f.write('    setTimeout(() => statusDiv.textContent = \'Jouez !\', 2000);\n')
    f.write('}\n\n')
    f.write('function resetDefaults() {\n')
    f.write('    location.reload();\n')
    f.write('}\n\n')
    f.write('function updateShapeColor(shapeIndex, color) {\n')
    f.write('    SHAPES[shapeIndex].color = color;\n')
    f.write('}\n\n')
    f.write('function updateBackground(color) {\n')
    f.write('    canvas.style.background = color;\n')
    f.write('}\n\n')
    f.write('function updateBorder(color) {\n')
    f.write('    canvas.style.borderColor = color;\n')
    f.write('}\n\n')
    f.write('function updatePageBackground(color) {\n')
    f.write('    document.body.style.background = color;\n')
    f.write('}\n\n')
    f.write('function toggleGodMode(enabled) {\n')
    f.write('    godMode = enabled;\n')
    f.write('}\n\n')
    f.write('function toggleTurbo(enabled) {\n')
    f.write('    turboMode = enabled;\n')
    f.write('}\n\n')
    f.write('function toggleUnlockAll(enabled) {\n')
    f.write('    if (enabled) {\n')
    f.write('        unlockedShapes = [0, 1, 2, 3, 4];\n')
    f.write('        updateShapeButtons();\n')
    f.write('    } else {\n')
    f.write('        unlockedShapes = [0];\n')
    f.write('        updateShapeButtons();\n')
    f.write('    }\n')
    f.write('}\n\n')
    f.write('function toggleInstructions() {\n')
    f.write('    alert(\'COMMANDES AVANCEES :\\n\\n\' +\n')
    f.write('          \'Clic : Utiliser le pouvoir (selon la forme)\\n\' +\n')
    f.write('          \'Laser : Pointez et cliquez pour tirer (coute energie)\\n\' +\n')
    f.write('          \'Dessin : En forme CUBE, maintenez pour tracer une zone\\n\' +\n')
    f.write('          \'Pause : Appuyez sur ESPACE\\n\\n\' +\n')
    f.write('          \'ASTUCE : Tuez 5 ennemis avec le laser pour debloquer le Cube !\\n\' +\n')
    f.write('          \'Les ennemis respawnent a leurs bases rouges\');\n')
    f.write('}\n\n')
    f.write('// FIN DU CODE - Aucune creation d\\'element, aucune fuite memoire\n')

print("‚úÖ Ecriture termin√©e")
print(f"üìÑ Taille du fichier : {os.path.getsize('Game.js')} octets")

# ============================================================================
# ETAPE 2 : Validation rapide
# ============================================================================
print()
print("üîç Validation rapide...")
with open('Game.js', 'r', encoding='utf-8') as f:
    content = f.read()
    if 'function updateEnemies()' in content and 'function drawEnemies()' in content:
        print("‚úÖ Fonctions principales pr√©sentes")
    else:
        print("‚ùå Erreur : fonctions manquantes")
        exit(1)

# ============================================================================
# ETAPE 3 : R√©sultat final
# ============================================================================
print()
print("="*70)
print("‚úÖ R√âCUP√âRATION TERMIN√âE AVEC SUCC√àS")
print("="*70)
print("\nüéÆ VOUS POUVEZ LANCER LE JEU :")
print("   Double-cliquez sur index.html")
print("   OU executez launcher_final_v4.1.bat -> [1] Corriger + Rapport")

input("\nAppuyez sur Entr√©e pour quitter...")