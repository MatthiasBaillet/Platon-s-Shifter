@echo off
setlocal

:: PATCH URGENT : Recrée fix_game_v4.py PROPREMENT
set "PY_FILE=%~dp0fix_game_v4.py"

:: Supprimer l'ancien fichier corrompu
if exist "%PY_FILE%" del "%PY_FILE%"

:: Créer le fichier correct ligne par ligne
echo #!/usr/bin/env python3 > "%PY_FILE%"
echo """ >> "%PY_FILE%"
echo Platon's Shifter - Correcteur v4.0 CORRIGE >> "%PY_FILE%"
echo NIVEAU SUPERIEUR : Detection fuites memoire + Analyse equilibre >> "%PY_FILE%"
echo """ >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo import re >> "%PY_FILE%"
echo import sys >> "%PY_FILE%"
echo from pathlib import Path >> "%PY_FILE%"
echo from typing import Dict, List, Tuple, Optional >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo CORRECTIONS_CONFIG = [ >> "%PY_FILE%"
echo     { >> "%PY_FILE%"
echo         "id": "taille_bases", >> "%PY_FILE%"
echo         "nom": "Reduire taille des bases (2.5?1.5)", >> "%PY_FILE%"
echo         "pattern": r"radius\s*:\s*GRID_SIZE\s*\*\s*2\.5", >> "%PY_FILE%"
echo         "replace": "radius: GRID_SIZE * 1.5", >> "%PY_FILE%"
echo         "marqueur": "CORRECT_TAILLE_BASES" >> "%PY_FILE%"
echo     }, >> "%PY_FILE%"
echo     { >> "%PY_FILE%"
echo         "id": "base_unique_ennemi", >> "%PY_FILE%"
echo         "nom": "Passer a une seule base ennemi", >> "%PY_FILE%"
echo         "pattern": r"let\s+enemyBases\s*=\s*\[\s*\]\s*;", >> "%PY_FILE%"
echo         "replace": "let enemyBase = null;", >> "%PY_FILE%"
echo         "marqueur": "CORRECT_BASE_UNIQUE" >> "%PY_FILE%"
echo     }, >> "%PY_FILE%"
echo     { >> "%PY_FILE%"
echo         "id": "bases_logique_spawn", >> "%PY_FILE%"
echo         "nom": "Simplifier logique de creation des bases", >> "%PY_FILE%"
echo         "pattern": r"// 3 bases ennemis[\s\S]*?enemyBases\.push\(base\);\s+}\s+}", >> "%PY_FILE%"
echo         "replace": """            # Une seule base ennemie >> "%PY_FILE%"
echo             enemyBase = { >> "%PY_FILE%"
echo                 x: canvas.width * 0.75, >> "%PY_FILE%"
echo                 y: canvas.height / 2, >> "%PY_FILE%"
echo                 radius: GRID_SIZE * 1.5 >> "%PY_FILE%"
echo             };""", >> "%PY_FILE%"
echo         "marqueur": "CORRECT_BASES_LOGIQUE" >> "%PY_FILE%"
echo     }, >> "%PY_FILE%"
echo     { >> "%PY_FILE%"
echo         "id": "uniformiser_style", >> "%PY_FILE%"
echo         "nom": "Uniformiser style base/terrain", >> "%PY_FILE%"
echo         "pattern": r"ctx\.fillText\s*\(\s*'BASE'\s*,\s*startBase\.x\s*,\s*startBase\.y\s*\+\s*5\s*\)\s*;", >> "%PY_FILE%"
echo         "replace": "", >> "%PY_FILE%"
echo         "marqueur": "CORRECT_STYLE" >> "%PY_FILE%"
echo     }, >> "%PY_FILE%"
echo     { >> "%PY_FILE%"
echo         "id": "respawn_ennemis", >> "%PY_FILE%"
echo         "nom": "Corriger respawn ennemis", >> "%PY_FILE%"
echo         "pattern": r"//\s*DETRUIRE\s*L'ENNEMI\s*enemies\.splice\s*\(\s*index\s*,\s*1\s*\)\s*;", >> "%PY_FILE%"
echo         "replace": "// CORRIGE: Respawn apres 1s\n                    enemies.splice(index, 1);\n                    setTimeout(() => enemies.push(createEnemy()), 1000);", >> "%PY_FILE%"
echo         "marqueur": "CORRECT_RESPAWN" >> "%PY_FILE%"
echo     } >> "%PY_FILE%"
echo ] >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo class Correction: >> "%PY_FILE%"
echo     def __init__(self, config: Dict): >> "%PY_FILE%"
echo         self.id = config["id"] >> "%PY_FILE%"
echo         self.nom = config["nom"] >> "%PY_FILE%"
echo         self.marqueur = config["marqueur"] >> "%PY_FILE%"
echo         self.pattern = config.get("pattern", "") >> "%PY_FILE%"
echo         self.replace = config.get("replace", "") >> "%PY_FILE%"
echo     def test(self, code: str) -> bool: >> "%PY_FILE%"
echo         return bool(re.search(self.pattern, code, re.MULTILINE ^| re.DOTALL)) >> "%PY_FILE%"
echo     def apply(self, code: str) -> Tuple[str, bool]: >> "%PY_FILE%"
echo         new_code = re.sub(self.pattern, self.replace, code, flags=re.MULTILINE ^| re.DOTALL) >> "%PY_FILE%"
echo         modified = new_code != code >> "%PY_FILE%"
echo         return new_code, modified >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo def detect_memory_leaks(code: str) -> Dict[str, List[str]]: >> "%PY_FILE%"
echo     leaks = {'listeners': [], 'intervals': []} >> "%PY_FILE%"
echo     listener_pattern = r'\.addEventListener\s*\(\s*[\''](\w+)[\'']\s*,' >> "%PY_FILE%"
echo     for match in re.finditer(listener_pattern, code): >> "%PY_FILE%"
echo         leaks['listeners'].append(f"Event '{match.group(1)}' non supprime") >> "%PY_FILE%"
echo     return leaks >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo def analyze_game_balance(code: str) -> Dict[str, List[str]]: >> "%PY_FILE%"
echo     balance = {'warnings': [], 'info': [], 'stats': {}} >> "%PY_FILE%"
echo     forms = ['Tetrahedron', 'Cube', 'Octahedron', 'Dodecahedron', 'Icosahedron'] >> "%PY_FILE%"
echo     for form in forms: >> "%PY_FILE%"
echo         energy_pattern = rf'function\s+{form.lower()}_power[\s\S]*?energy\s*-\=\s*(\d+)' >> "%PY_FILE%"
echo         match = re.search(energy_pattern, code) >> "%PY_FILE%"
echo         energy = int(match.group(1)) if match else 0 >> "%PY_FILE%"
echo         balance['stats'][form] = {'energy': energy, 'damage': energy * 3} >> "%PY_FILE%"
echo         if energy > 10: >> "%PY_FILE%"
echo             balance['warnings'].append(f"{form}: Cout energie eleve") >> "%PY_FILE%"
echo     return balance >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo def main(): >> "%PY_FILE%"
echo     import argparse >> "%PY_FILE%"
echo     parser = argparse.ArgumentParser() >> "%PY_FILE%"
echo     parser.add_argument('file') >> "%PY_FILE%"
echo     parser.add_argument('--dry-run', action='store_true') >> "%PY_FILE%"
echo     parser.add_argument('--advanced-report', action='store_true') >> "%PY_FILE%"
echo     args = parser.parse_args() >> "%PY_FILE%"
echo     with open(args.file, 'r', encoding='utf-8', errors='ignore') as f: >> "%PY_FILE%"
echo         content = f.read() >> "%PY_FILE%"
echo     corrections = [Correction(c) for c in CORRECTIONS_CONFIG] >> "%PY_FILE%"
echo     applied = [] >> "%PY_FILE%"
echo     print("=" * 70) >> "%PY_FILE%"
echo     print("NIVEAU SUPERIEUR ACTIVE") >> "%PY_FILE%"
echo     print("=" * 70) >> "%PY_FILE%"
echo     for corr in corrections: >> "%PY_FILE%"
echo         if corr.test(content): >> "%PY_FILE%"
echo             content, modified = corr.apply(content) >> "%PY_FILE%"
echo             if modified: >> "%PY_FILE%"
echo                 applied.append(corr.nom) >> "%PY_FILE%"
echo                 content += f"\n// {corr.marqueur}\n" >> "%PY_FILE%"
echo     if args.advanced_report: >> "%PY_FILE%"
echo         print("\n[ANALYSE FUITES MEMOIRE]") >> "%PY_FILE%"
echo         leaks = detect_memory_leaks(content) >> "%PY_FILE%"
echo         for leak in leaks['listeners']: >> "%PY_FILE%"
echo             print(f"  - {leak}") >> "%PY_FILE%"
echo         print("\n[ANALYSE EQUILIBRE]") >> "%PY_FILE%"
echo         balance = analyze_game_balance(content) >> "%PY_FILE%"
echo         for warn in balance['warnings']: >> "%PY_FILE%"
echo             print(f"  - {warn}") >> "%PY_FILE%"
echo     output = args.file.replace('.js', '_fixed.js') >> "%PY_FILE%"
echo     with open(output, 'w', encoding='utf-8') as f: >> "%PY_FILE%"
echo         f.write(content) >> "%PY_FILE%"
echo     print(f"\nFichier corrige: {output}") >> "%PY_FILE%"
echo. >> "%PY_FILE%"
echo if __name__ == "__main__": >> "%PY_FILE%"
echo     main() >> "%PY_FILE%"

if exist "%PY_FILE%" (
    echo ? PATCH APPLIQUE !
    echo Le fichier fix_game_v4.py a ete recree.
    echo.
    echo APPUYEZ sur Entrée pour tester...
    pause >nul
) else (
    echo ? ERREUR
    pause
)

exit /b 0